import sqlite3
from fastexcel import read_excel
import os

# Paths to your folders and user ID file
folder1_path = "path/to/folder1"
folder2_path = "path/to/folder2"
user_id_file = "path/to/user_ids.xlsx"

# Connect to a file-based SQLite database
db_file = "large_data.db"
if os.path.exists(db_file):
    os.remove(db_file)  # Clean start
conn = sqlite3.connect(db_file)
cursor = conn.cursor()

# Function to process a folder and insert rows into a table
def process_folder(folder_path, table_name):
    headers = None
    rows_inserted = 0
    user_id_idx = None
    
    for filename in os.listdir(folder_path):
        if filename.endswith(".xlsx"):
            file_path = os.path.join(folder_path, filename)
            try:
                excel_file = read_excel(file_path)
                if not hasattr(excel_file, 'sheet_names'):
                    print(f"Error: {file_path} did not load correctly, no sheet_names attribute")
                    continue
                
                sheet_names = excel_file.sheet_names
                print(f"Sheet names in {file_path}: {sheet_names}")
                
                for sheet_name in sheet_names:
                    if "SQL" in sheet_name:
                        print(f"Skipping sheet '{sheet_name}' in {file_path}")
                        continue
                    
                    # Load sheet explicitly
                    try:
                        sheet = excel_file.load_sheet(sheet_name)
                    except Exception as e:
                        print(f"Error loading sheet '{sheet_name}' in {file_path}: {e}")
                        continue
                    
                    print(f"Processing sheet '{sheet_name}' in {file_path}")
                    for i, row in enumerate(sheet.to_record()):
                        if not isinstance(row, (list, tuple)):
                            print(f"Error: Row {i} in {sheet_name} is not a sequence: {row}")
                            continue
                        
                        if i == 0 and sheet_name == sheet_names[0]:  # First sheetâ€™s first row = headers
                            if not headers:
                                headers = [str(col) for col in row]
                                columns = ", ".join([f'"{h}" TEXT' for h in headers])
                                cursor.execute(f"CREATE TABLE IF NOT EXISTS {table_name} ({columns})")
                                print(f"Headers for {table_name}: {headers}")
                                if table_name == "table1":
                                    try:
                                        user_id_idx = headers.index("user_id")
                                    except ValueError:
                                        print(f"Warning: 'user_id' not found in headers for {table_name}")
                            continue
                        
                        values = list(row)
                        if table_name == "table1" and user_id_idx is not None and len(values) > user_id_idx and values[user_id_idx] is not None:
                            values[user_id_idx] = str(values[user_id_idx]).upper()
                        
                        if len(values) < len(headers):
                            values.extend([None] * (len(headers) - len(values)))
                        elif len(values) > len(headers):
                            print(f"Warning: {file_path} sheet '{sheet_name}' row {i+1} has {len(values)} columns, truncating to {len(headers)}")
                            values = values[:len(headers)]
                        
                        cursor.execute(f"INSERT INTO {table_name} VALUES ({','.join(['?' for _ in headers])})", values)
                        rows_inserted += 1
                        if i < 5:  # Print first few rows
                            print(f"Row {i+1} in {sheet_name}: {values}")
                    
            except Exception as e:
                print(f"Error processing {file_path}: {e}")
    
    conn.commit()
    print(f"{table_name}: Inserted {rows_inserted} rows with {len(headers) if headers else 0} columns")
    return headers

# Process both folders
headers1 = process_folder(folder1_path, "table1")
headers2 = process_folder(folder2_path, "table2")

# Load user IDs and convert to uppercase
try:
    excel_file = read_excel(user_id_file)
    if not hasattr(excel_file, 'sheet_names'):
        raise ValueError("User ID file did not load correctly, no sheet_names")
    
    sheet_name = excel_file.sheet_names[0]
    sheet = excel_file.load_sheet(sheet_name)
    user_ids = []
    for row in sheet.to_record():
        if not isinstance(row, (list, tuple)):
            print(f"Error: Row in {user_id_file} is not a sequence: {row}")
            continue
        if len(row) > 0 and row[0] is not None:
            user_ids.append(str(row[0]).upper())
    print(f"First 5 user IDs (uppercase): {user_ids[:5]}")
except Exception as e:
    print(f"Error reading user IDs from {user_id_file}: {e}")
    user_ids = []

# Perform LEFT JOIN and filter with UPPER()
if headers1 and headers2:
    query = f"""
    CREATE TABLE merged_result AS
    SELECT t1.*, t2.*
    FROM table1 t1
    LEFT JOIN table2 t2
    ON UPPER(t1."key_column1") = UPPER(t2."key_column2")
    WHERE UPPER(t1."user_id") IN ({','.join(['?' for _ in user_ids])})
    """
    try:
        cursor.execute(query, user_ids)
        conn.commit()
        print("Join and filter completed (case-insensitive).")
    except sqlite3.OperationalError as e:
        print(f"Error during JOIN: {e}")
        print("Check if 'key_column1', 'key_column2', and 'user_id' match the headers above.")
else:
    print("Skipping JOIN due to missing headers in one or both tables.")

# Export result to CSV
try:
    cursor.execute("SELECT * FROM merged_result")
    with open("merged_filtered_result.csv", "w", encoding="utf-8") as f:
        headers = [desc[0] for desc in cursor.description]
        f.write(",".join(headers) + "\n")
        for row in cursor:
            f.write(",".join([str(val or "") for val in row]) + "\n")
    print("Result saved to 'merged_filtered_result.csv'.")
except sqlite3.OperationalError:
    print("No merged_result table to export - JOIN may have failed.")

# Clean up
conn.close()